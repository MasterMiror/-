#操作系统课程学习笔记

##C1 操作系统概述

常用四大操作系统:Win Mac Linux Unix

###操作系统的基本功能

  提供操作界面

  控制程序运行

  管理系统资源

  配置系统参数

  监控系统状态

  工具软件集合

###操作系统的功能

  进程管理（CPU管理）[控制、调度、通信]

  内存管理[内存分配 内存共享 内存保护 虚拟内存]

  设备管理[设备的分配和调度 设备传输控制 设备驱动]

  文件管理[存储空间管理 文件的操作 目录的操作 文件和目录的存取权限管理]

Def操作系统是一个大型系统程序,它负责给用户提供接口,方便用户控制计算机；负责为应用程序分配和调度软硬件资源,并且控制程序的并发活动,帮助用户存取和保护信息.

系统程序在层次上处于应用程序和硬件之间的部分.


###操作系统的发展历程

  电子管时代

  晶体管时代

  集成电路时代

  大规模集成电路时代

###操作系统发展的四个典型阶段

  手工操作（无操作系统阶段）

  单道批处理系统

  多道批处理系统

  分时系统

###分时技术

由于多道批处理系统存在作业处理时间长、交互能力差等等缺点,在60年代基于中断技术和通道技术的出现而发展出了分时操作系统
它的交互性更高、响应更加快速,也支持多用户多任务.主机采用分时技术轮流为每个使用串口线接入主机的终端提供服务,对于每个终端来说都认为自己是独占主机的.

###分时技术的概念

  主机以很短的时间片（50ms）为单位,把cpu轮流分配给每个终端使用,直到全部作业被运行完.由于时间片非常短,在终端数量不多的情况下,每个终端都能重新获得CPU,使得每个终端都能获得及时响应.

  等待周期==时间片x终端数量

  大型分时系统的一种时间Multics项目.

  Unix是第一个实用化的分时系统,它的创新之处在于其可移植性和硬件无关性.它引入了“特殊文件”这一概念,将外设看作一种文件对外设进行统一管理.


###操作系统的典型案例

*微机操作系统* CP/M MacOS DOS Windows

*实时操作系统* 火控 雷达 跟踪识别等等系统

*网络操作系统* 普通操作系统+网络通信+网络服务



=======================================================

#C2操作系统逻辑结构

##分层的操作系统

    资源分配与调度
        ｜｜
        ｜｜
      文件存取
        ｜｜
        ｜｜
      I/O处理
        ｜｜
        ｜｜
      存储管理
        ｜｜
        ｜｜
      进程管理
  初级中断管理/裸机/处理机分派

##分层的原则

硬件相关————最底层

外部特征————最外层

中间层————调用次序或消息传递顺序

共性的服务————较低层

活跃功能————较低层

分层的有点是:1结构清晰,避免循环调用；2.容易将问题局部化,系统的正确性容易保证；3.有利于系统的维护、扩充、移植.

##微内核结构

操作系统 == 微内核 + 核外服务器

微内核（足够小,提供OS最基本的核心功能和服务）

核外服务器 （能完成OS大部分的服务功能,等待App提出请求）

相关项目可以参考Linux和Minix


##操作系统的逻辑结构

CPU的态 即CPU的工作状态,对资源和权限使用指令的描述.

态可分为:核态（Kernel mode 可访问所有资源和执行所有指令）；用户态（User mode 仅可以访问部分资源,其他资源受限）；管态(Supervisor mode 介于核态和用户态之间)

用户态在以下四种情况发生时可向核态转换:

1.请求OS服务

2.中断发生

3.Error

4.企图执行特权指令

核态向用户态转移的情况一般是执行中断返回:IRET

硬件按“态”来区分CPU的咋混改

OS按“进程”来区分CPU的状态

##存储器

###存储器的分类:

1.按读写方式可分为RAM和ROM

2.按存储材料可分为半导体存储器、磁存储器、光存储器

3.按和CPU的联系可分为主存和辅存

一个理想的储存体系应该应对不同的存储需求有不同的成本和架构,它的大致要求是速度快、容量大、成本低


##CPU读取指令互数据时的访问顺序:

1.访问缓存

2.访问内存

3.访问辅存

##中断

###定义
中断即CPU对突发的外部事件的反应过程或者机制（CPU收到外部信号之后停止当前工作去处理外部事件,随后回到原来的中断点继续工作）

引入中断的目的在于实现并发、实现实时处理、实现故障的自动处理

引起中断的事件被称为中断源,中断分为强迫性中断和自愿中断.也可分为外中断和内中断,外中断由CPU外部事件引发,内中断相反；外中断又分为可屏蔽和不可屏蔽,依据是CPU是否可以不响应.

断点:即程序中断的地方 CS:IP

现场:程序正确运行所依赖的信息集合.

##中断响应的过程:

1.识别中断源

2.保护断点和现场

3.装入中断服务程序的入口地址（CS:IP）

4.装入中断服务程序

5.恢复现场和断点

6.中断返回:IRET

##中断响应的实质是交换指令执行地址和交换CPU的态


=======================================================

#C3 操作系统用户界面

##BIOS和主引导记录MBR

###实模式和保护模式

####实模式（REAL MODE）

程序按照8086寻址方法访问0h-FFFFFh（1MB）空间

寻址方式:物理寻址（20bit） = 段地址:偏移地址

例子:读取1M空间

前640K [00000-9FFFF]:基本内存

中128K [A0000-BFFFF]:显卡显存

末尾256K [C0000-FFFFF]:BIOS

C0000 -- C7FFF:显卡BIOS

C8000 - CBFFF:IDE控制器BIOS

F0000-FFFFF:最后64K 系统BIOS

CPU单任务运行

####保护模式（内存保护模式 PROTECT MODE）

寻址方式:段（32bit）和偏移量（32bit）寻址4GB空间

段页式寻址机制（段 页）

寻你地址,进程,封闭空间

应用承诺许和操作系统的运行环境都被保护

CPU支持多任务

###系统BIOS

####Basic I/O System(Frimware固件)

基本输入/输出系统

位置:F0000 - FFFFF

功能:

  系统启动配置

  基本的设备I/O服务

  系统的加电自检和启动

####CMOS设置 启动时按DEL就会进入CMOS设置,即使什么OS都没装也会进到这里

###MBR/硬盘分区/格式化


MBR ===> Windows FAT32/NTFS ===>Linux EXT2/EXT3/... ===>其他文件系统

分区启动扇叶 PBR

主启动扇叶:完成OS加载或者启动你难过管理功能

  提供菜单:让用户选择不同的启动项 实现多重启动

  加载核心文件:直接指向可启动区加载操作系统

  跳转:将启动管理功能转交给其他Loader

运行过程: POST->CMOS设置（硬盘启动）->读取MBR->控制权交给MBR

MBR读取分区表,找到其中的活动分区,确认其他分区都是不活动的,MBR读取互动分区中的第一个分区并将其加载到内存中.

PBR继续控制后续引导过程

###操作系统启动过程:初始引导==>核心初始化==>系统初始化

####初始引导 它的目的在于把OS核心装入内存并使之开始工作接管计算机系统

过程:加电 JUMP POST ==>BIOS中的启动程序运行 ==>引导程序运行==>OS内核逐步加载剩余OS部分,最后完全控制计算机

####核心初始化 它的目的在于初始化系统核心数据

它的典型工作又 各种寄存器的初始化；存储系统和页表的初始化；核心进程的构建

####系统初始化 它的目的在于为用户使用系统作准备 使系统处于待命状态

它的主要工作有 初始化文件管理系统 初始化网络系统 初始化控制台 初始化图形界面

例子 Windows的启动过程

POST 加电后BIOS启动主机自检程序

初始引导 BIOS从MBR读入引导程序,装入内存的特定位置； 引导程序启动DOS7.0调入操作系统核心；Windows开始接管系统

核心初始化 资源状态、核心数据等初始化

系统初始化 GUI界面生成,系统处于待命/消息接收状态

例子 LINUX系统启动状态

POST->MBR->KERNEL映像->KERNEL映像自解压并执行->内核初始化->内核启动


##操作系统的生成

操作系统的生成嫩难过是为了满足特定硬件环境和用户需要,组装和构建操作系统的过程.

操作系统生成的主要步骤,根据硬件环境/用户要求配置功能模块和狗仔参数

构建OS的映像

系统生成的前提有三:1.操作系统由可拆装模块构成；2有交互式配置工具；3.有映像构建工具

//本节课的实验是配置LINUX内核//

##操作系统的用户界面
Shell是操作系统与用户的交互界面 通过控制台执行命令的方式来进行交互,SHell本身不执行命令,仅仅是管理和组织

Shell脚本由Shell环境解释运行,需要用Chmod赋予可执行属性 x

一般执行使用bash

##系统调用

定义 操作系统内核为应用程序提供的服务/函数

特点 一般涉及核心资源或者硬件编号 每个系统调用具有唯一编号 调用过程产生中断 自愿中断

大体过程是应用程序执行过程中调用函数 产生中断,函数调用系统内核的X功能 随后恢复调用现场 应用继续执行

=======================================================
#C4 进程 【重点】

###基本概念

进程是程序在某个数据集合上的一次运行活动

数据集合:软/硬件环境,多个进程共存/共享环境

进程的特征:

动态性:进程是一个一次性执行的过程,动态的产生和消亡

并发性:进程同其他进程一起向前推进

异步性:进程按照各自的速度向前推进

独立性:进程是系统分配资源和调度CPU的单位

它和程序的区别在于下列三点:1.进程是动态的,程序是静态的;2.暂停和长存,程序是长存的,进程是驻留的；3.一个程序可能对应多个进程

进程可以依据使用资源的权限分为系统进程和用户进程,可根据对CPU的依赖性分为偏CPU进程和偏I/O进程；其他标准亦可分

###进程的状态

分为三种:1.运行状态；2.就绪状态;3.阻塞状态

###进程的描述

重要概念*进程控制块PCB* 这个概念是进程的标志,创建进程时创建PCB；撤销进程后撤销PCB

进程 == 程序 + PCB

###进程的控制

这个概念用于描述在进程生存期间对其全部行为的控制,其中有4个典型的控制行为分别为:创建、阻塞、撤销、唤醒

####创建

创建一个空白的PCB 赋予进程标识符ID 分配空间 初始化 随后插入进程队列

####撤销

在PCB队列中检索出该PCB  获取去运行状态 若处在运行态,立即终止  释放占有资源  讲进程从你PCB队列中移除

####阻塞

停止运行   将PCB由运行态改为阻塞态 插入相应原因的阻塞队列 专调度程序

####唤醒

####进程控制原语 由若干指令构成的具有特定工程的函数 具有原子性

以上四种操作对应四种原语

####Windows 通过 CreateProcess()函数创建进程

####Linux通过fork()函数创建进程

ps:由于父进程和子进程是并发关系,不加控制的情况下不能确定先后

##线程

定义:线程是一个可由CPU直接运行的实体；一个进程可以创造多个线程；多个线程共享CPU可以实现并发运行.

例子 Java语言中的CreateThread()等系列函数 GPSGateway中写过这个

单线程程序:只有一个线程,Windows程序缺省只有1个线程

多线程程序:整个进程至少有2个线程,主线程和至少一个用户线程

线程技术典型应用与需要多个功能并发运行的场景和为了提高窗口的交互性,给后台执行单独写一个线程以避免后台在运行的时候导致交互界面卡死.

使用线程的麻烦之处在于:程序难以调试；线程安全问题；并发过程不好控制.

##临界区和锁

临界资源:一次只允许一个进程独占访问（使用）的资源

临界区和临界资源的特性有:具有排他性；并发进程不能进入临界区

临界区设计四原则:忙则等待；空闲让进；有限等待；让权等待

锁的本质是一个标志,标志线程的可用和不可用状态,实际应该是一个Boolean型变量或者其他实例,通过指定方法去修改这个flag的值.

##同步和P-V操作

进程中可能存在互斥的情况,诸如临界区中的变量.由于多个进程共享了独占性资源,必须对资源的存取顺序进行协调.同步即若干进程为了完成一个共同呢的任务需要互相协调运行步伐.这一部分设计到之前学习的AOE网的知识.

####信号灯的概念,这是一种用于控制同步的基本思想,进程在运行过程中首信号灯的控制没,并可以改变信号灯的状态.

  在这个过程中 信号灯的状态是可以阻塞或唤醒的

信号灯的数据结构,需要定义一个二元矢量（S,q）S为信号量,初始非负,q为PCB队列,初始为空

这个数据结构只对应两个操作 P操作和V操作 分别代指通过和释放

####P操作的原理:S值-1 如果大于等于0则进程继续,若小于0 则进程阻塞并加入队列q中并转调度函数

####V操作的原理:S值+1 若和大于0,则进程继续,若小于0 则该进程同时从q中唤醒一个进程

P-V操作被设计出来用于解决同步和互斥的问题,具体过程是在进入临界区之前先执行P草哦做,离开临界区之后执行V操作.

可以用P-V操作实现同步机制,让运行条件不满足时进程暂停；运行条件满足时,进程继续.

P-V操作应用于同步操作的基本思路:

  暂停当前进程,在关键操作之前执行P操作,继续进程,在关键操作执行之后执行V操作.

###进程通信

使用管道机制来实现,管道的定义是一个进程A可以通过管道将数据传输给另一个进程B,前者向管道输入数据,后者向管道读取数据.（有点像Kafka的Consumer和Produceer模型）

ps:管道通信是单向的,如果要实现双向通信则需要建立两个管道.

在Linux系统中存在*信号*这一通信机制,所谓信号即向进程发送一个通知,通知某一事件已发生. 收到信号的进程可以立即执行操作.

例子 Ctrl+C 即杀死一个进程 收到Signal 执行结束进程操作 Ctrl+Z是挂起 kill-9顾名思义

信号的产生可以是特殊键盘组合、执行终端命令、调用对应函数、硬件异常或者核异常.

=======================================================

#C5死锁

##哲学家吃饭问题,五个哲学家对应5支筷子,对应P-V操作解决这个问题.

在两个或多个进程中,两个或多个进程多持有某种资源,但又继续申请其他某种已经持有的资源,每个进程都拥有其运行所需的一部分资源,但又都不够,从而每个进程都不能向前推进,陷于阻塞状态,这种状态称之为死锁.

##死锁的起因,根本原因是系统资源有限,或者并发推进的顺序不当.

参与死锁的进程大概是两个

参与死锁的进程至少有2个已经占有资源

参与死锁的进程都在等待资源

参与死锁的进程是当前系统中所有进程的子集

死锁回大量占用系统资源

##死锁的起因

###死锁的必要条件

1.互斥条件

2.不剥夺条件

3.环路条件

4.部分分配条件

####预防死锁

破坏上述4个条件

####避免死锁

银行家算法

只需要较弱的限制条件 算法实现难度大

####检测和恢复死锁

允许死锁发生,通过检测机制及时检测出死锁并将进程从这个过程中解脱出来

预先静态分析发 可能被延迟执行 应用开销可能比较大 资源利用率低

有序资源分配法 给系统中的每一个资源分配一个唯一的序号 每次进程在申请资源的时候只能申请序号最大的资源 每次申请只能申请序号大于M的资源 而不能再申请小于或者等于M的资源

这种方法*序号是递增的*

=======================================================

#C6进程调度

在合适的时候以一定策略来选择一个就绪进程进行运行.

进程调度的目标

1.响应速度尽量快

2.处理时间尽可能短

3.系统吞吐量尽可能大

4.资源利用率尽可能高

5.对进程要公平

6.避免饥饿

7.避免死锁

##典型的调度算法

1.先来先服务调度 First Come First Service

按照作业进入系统的先后时间来挑选做噢耶,先进入系统的作业优先被运行.

特点:容易实现,效率不高

只考虑作业等候时间,不考虑运行时间的长短.

2.短作业优先调度算法 Short Job First

选取时间最短者优先调度资源

特点:容易造成饥饿现象

3.响应比高者优先调度算法

响应比 = 响应时间/运行时间 = (响应时间+运行时间)/响应时间

算法:选择响应比最高的作业优先投入运行.

4.优先数调度

算法:根据进程优先数,把CPU分配给优先数最高的进程.

优先数 = 静态优先数 + 动态优先数

静态优先数:在进程创建时产生的,保持不变 它会考虑进程运行所需的资源和长短、类型等等.

动态优先数:随着进程运行而改变

5.循环轮转屌哦度 Round Robin

利用队列,把所有的就绪进程按照先入先出的办法,以时间片q为单位使用CPU,在逻辑上所有的进程构成一个环.

优点:公平、交互

q不能太大

循环轮转调度算法,是第5中的改进,q的大小可以调整.

##Linux中的进程调度策略

task_struct是调度时候的依据

子进程新建时的counter会从父进程的时间片中继承一半,防止恶意用户无限制创建进程调度cpu资源

中断处理过程直接调用schedule（） 该函数用户态无法调度

=======================================================

#C7内存管理

###静态地址映射

程序装入时由操作系统完成逻辑地址到物理地址的映射

逻辑地址:VA

装入地址:BA

物理地址:MA = BA+VA

###存储器功能需求

容量足够大

速度足够快

信息可以永久保存

多道程序并行

#实际的存储器体系

Cache + 内存 + 辅存

基本原理:当内存不够用的时,用辅存在支援内存；暂时不运行的模块换出到辅存上,必要时换入内存.

###固定地址映射

定义:编程和编译时确定逻辑地址和物理地址的映射关系.

特点:程序的加载必须放在指定的内存区域,但是容易产生地址冲突,运行失败.

特点:程序运行之前可以确定映射关系,程序装入之后不能移动,必须放回到原来的位置,程序占用连续的内存空间.


###静态地址映射

定义:程序装入时由操作系统完成逻辑地址到物理地址的映射.

特点:需要在程序运行之前确定映射关系；程序装入后不能移动,如果要移动必须放回原来的位置；程序会占用连续的内存空间.

###动态地址映射

定义:在程序执行过程中把逻辑地址转换为物理地址.例如MOV AX,[500].访问500单元时执行地址转换.

映射过程:

MA = BA + VA

特点:程序占用的内存空间可动态变化,要求及时更新基址BA,程序不要求连续占用内存空间.但是基址BA系统应该知道.便于多个进程共享代码.

缺点:硬件支持；软件复杂.

虚拟内存用于解决程序过大或者过多的情况,或者多个程序并发时地址冲突,不能运行.

虚拟内存时面向用户的虚拟封闭存储空间；它的地址空间是线性的,是和物理地址分离的.

##存储管理 物理内存管理

分区管理分为单一分区存储管理和分区存储管理（这里又分为动态分区和固定分区）

单一分区管理:用户不分区,完全被一个程序占用,诸如Dos.这种情况不需要复杂的硬件支持,适用于单用户任务OS.

缺点:程序运行会占据整个内存,即使是小程序也是如此,所以一条明显的缺点是内存浪费,利用率低.

分区存储管理:这种方式把用户区内存划分为若干大小不等的分区,供不同程序使用.

固定分区:把内存固定地划分为若干个大小不能地分区供各个程序使用,每个分区地大小和位置都固定,系统运行期间不再重新划分.分区表,记录分区地位置、大小和使用标志.

使用特点:在程序装入前,内存已经被分区,不再改变.每个分区的大小不同,适应不同大小的程序.系统要维护分区表.

缺点:浪费内存,程序比所在的分区小.大程序可能无法运行.

建议:根据分区表安排程序装入顺序,使每个程序都能找到合适的分区运行,当程序的大小、个数、装入顺序都固定时,内存使用效率很高.


动态分区:在程序装入时创建分区,使分区的大小刚好和程序的大小相等.

特点:动态建立分区.分区的大小和个数均可以改变；存在内存碎片.

动态分区需要解决的问题:分配问题；分区的选择问题；分区的回收问题；解决内存碎片问题.

###分区的分配

大致过程如下:

1.从空闲表的第一个分区开始,寻找>=s的空间（S为用户要求的大小）

2.找到后从分区中分割出大小为s的部分给用户使用.

3.分割后的剩余部分作为空闲去仍然登记在空闲区表中.

放置策略是空闲区表的排序

1.按空闲区位置递增顺序,首次适应算法.首次适应算法的前提是空闲区表按首地址递增排序,它的优点是尽可能优先使用低地址空间,当需要较大分区时在高地址分区又较大的满足可能性.

2.按空闲区位置递减排序

3.按空闲区大小的递增排序,最佳适应算法.最佳适应算法会尽可能优先使用较小的空闲区,保留较大的空闲区,需要较大的分区时比较可能满足.它的前提是空闲区表按大小递增排序.

4.按空闲去大小的递减排序,最坏适应算法.它的前提是空闲表按照大小递减排序.它的优点是大空闲区分割后剩下的部分还是很大,还能装下较大的程序.特点是仅作一次查找就可以找到所需要的分区.

分区的回收:功能是程序释放分区,登记到空闲区表中以便再分配.

回收算法:要考虑到释放区于现有的空闲区是否相邻,如果不相邻则插入空闲区表.如果相邻,则与空闲区表合并后更新空闲区表.*这个地方理解不好,需要补充一些例子*

####覆盖 Overlay

目的:在较小的内存空间中运行较大的程序

内存分区:常驻区.被某段单独且固定地占用,可划分多个；覆盖区,能被多段公用,可划分多个.

覆盖的缺点:编程复杂；程序执行时间长（由于从外存装入内存耗时）

####内存交换技术（Swapping)

原理:内存不够时把进程写到磁盘（换出Swap Out）当进程要运行时重新写回内存（换入Swap In）

优点:增加进程的并发数,不考虑程序的结构.

缺点:换入和换出增加CPU开销；交换的单位太大.

需要考虑的问题:减少交换传送的信息量（模块/段）；外存交换空间的管理方法；程序换入时的地址重定位.

####内存碎片

影响:过小的空闲区,实际难以利用；会降低内存有效利用率.

动态分区的缺点:内存反复分配和分割.

解决方法1:规定门限值；空闲分割区时,若剩余部分小于门限值,则此区不进行分割,而是全部分配给用户.

方法2:将所有空闲区集中在一起构成一个大的空闲区.拼接的时机在于:释放区回收的时候（拼接频率过大,系统开销大）；系统内找不到足够大的空闲区时（空闲区管理复杂）；定期（空闲区管理复杂）

####碎片问题

拼接技术的缺点:消耗系统资源；离线拼接；重新定义作业.

方法3:接触程序占用连续内存空间内才能运行的限制,具体方法是把程序拆分成多个部分装入不同的分区充分利用碎片.

##虚拟内存管理

###页式虚拟内存管理概念

物理内存管理的类型和特点：

1.源程序直接使用内存的物理地址,但是程序间容易访问冲突.

2.源程序必须全部装入内存才能运行,如果内存太小则程序无法运行.

3.程序占用连续的一片内存,这会导致内存碎片的产生.

4.多个程序同时运行容易互相干扰,不安全.

为了改善上述问题共有三种方法：内存拼接；对换技术；覆盖技术.

虚拟内存管理技术的目标是：

1.使得大的程序能在较小的内存空间运行.

2.使得多个程序能在较小的内存中运行（能容纳下）

3.使得多个程序并发运行时地址不冲突（方便、高效）

4.使得内存利用效率高；无碎片,共享方便.

程序运行时的局部性：程序在一个优先的时间段内访问的代码和数据往往集中在优先的地址番位内；把程序一部分装入内存在较大的概率上也足够让其运行一小段时间.

典型的虚拟内存管理方式：

1.页式虚拟存储管理.

2.段式虚拟存储管理.

3.段页式虚拟存储管理.

####页式虚拟存储管理会把进程空间和内存空间划分成等大小的小片,小片的大小通常为2的N次方.进程的小片为页,内存的小片为页框.

内存以页框为单位分配使用,进程以页为单位装入内存.

只把程序部分页装入内存便可运行;页在内存中占用的页框不必相邻;需要新页时,按需从你硬盘调入内存;不再运行的页及时删除腾出空间.

*进程占用的页数可以在Windows任务管理器中查看到*

###页式系统中的地址

虚拟地址(VA)可分解成页号P和页内偏移W

P = VA/页的大小

W = VA%页的大小

例子

VA = 2500 页面大小1K (2^10)

P = 2500 / 1024 = 2

W = 2500 % 1024 = 452

P和W的另一种计算方法

已知页的大小为2^n单元

P = VA >> n

W = 低 n 位 = VA && (2^n - 1)

记录页与页框之间的对应关机叫做页表.

页式地址映射的功能式:虚拟地址--->物理地址

过程:

1.从VA分离页号P和页偏移W

2.查页表

3.计算MA   MA  = P` x 页面大小 + W

例子:

MOC R1 [2500]

| 页号 | 页框号 | 其他特性 |
|-----|-------|------|
| 0   | 4     | ... |
| 1   | 2     | ... |
| 2   | 7     | ... |

1.分离P,W

P = VA/页面大小 = 2500 / 1024 = 2

W = VA%页面大小 = 2500 % 1024 = 452

2.查找页表

P = 2 P` = 7

3.计算MA = P` x 页面大小 + W

MA = 7 * 1024 + 452 =7620

####快表技术和页面共享技术

快表(Cache)的概念

*慢表*:页面放在内存中

*快表*:页面放在Cache中

特点:容量小,访问快,成本高;快表是慢表部分内容的复制;地址映射优先访问快表,如果找到则称为命中,如果没有命中则访问慢表,同时更新快表.

*合理的页面调度能使快表具有较高的命中率*

页面共享的例子之文本编辑器

文本编辑器:150KB代码段和50KB数据段

有10进程并发执行该文本编辑器

占用内存 = 10 x (150 + 50) KB = 2M

如果采用代码段共享,代码段在内存中只有一份真实存储

  占用内存 = 150 + 10 x 50 = 650KB

页面共享的原理,在不同进程的页表中填上相同的页框号,多个进程能访问相同的内存空间,从而实现页面共享.

页面共享在内存中只有一份真实存储,节省内存.

####页表扩充——带中断位的页表

扩充有中断位和辅存地址的页表

中断位I——标识该页是否存在内存 若I=1,则不在内存 若I=0,则在内存

缺页中断:在地址映射的过程中,当所要访问的目的页不在内存呢时,系统产生异常中断没——缺页中断.

缺页中断处理程序:中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中,并更新表中该页对应的页框号以及修改中断位I为0.

缺页率 f = 缺页次数/访问页面的总次数

命中率 = 1 - f

####页面淘汰策略

淘汰策略谁选择淘汰哪一页的规则

页面抖动是指页面在内存和辅存间频繁交换的现象,抖动会导致系统效率下降.

好的淘汰策略户具有较低的缺页率(也有较高的命中率),页面抖动也较少.

常用的淘汰算法,最佳淘汰算法(OPT算法),先入先出淘汰算法(FIFO算法),最久未使用淘汰算法(LRU算法),最不经常使用算法(LFU算法)

*最佳算法OPT* 淘汰以后不需要或最远的将来才会用到的页面,理论上最佳,实践中无法实践.

*先入先出算法FIFO* 淘汰在内存中停留时间最长的算法.按页面进入内存的时间排序,淘汰队头页面.

*最久未使用算法LRU* 淘汰最长时间未被使用的页面

LRU可被硬件实现,页面设置一个位移寄存器R,每当页面被访问则将其重制1,周期性地(周期很短)将所有页面的R左移1位(右边补0),淘汰R最大的页面.R的位数越多,周期越小就越精确,但是硬件成本就越高.若R的位数人太小,可能同时出现多个为0的页面,难以比较.

*LRU的近似算法*

利用页表访问位,页被访问时其值由硬件置1,软件周期性(T)地将所有访问位置0,当淘汰页面时根据该页面访问位来判断是否淘汰.(访问位1,则在T时间内该页面被访问过,淘汰,反之不淘汰)

缺点:周期T难以确定,如果太小,访问位为0的页过多,找不到合适的淘汰页;若太大,访问位为1的页过多,找不到合适的淘汰页.

*最不经常使用算法LFU*选择到当前时间为止,被访问次数最少的页面,每页设置访问计数器,当页面被访问时,该页面的访问计数器加1;发生中断时,淘汰数值最小的页面,并将所有计数器清0.

####缺页因素和页式系统缺点

缺页因素:淘汰算法;分配给进程的页框数(页框越少,越容易缺页);页本身的大小.

页面大小的选择:太大(浪费内存,极限是分区存储);太小(页面增多,页表长度增加,浪费内存,换页频繁,效率低);页面常见大小(2的整数次幂:1KB、2KB、4KB)

影响缺页次数的因素:淘汰算法;分配给进程的页框数(页框越少越容易缺页);页面本身的大小(页面越小,越容易缺页);程序的编制方法(局部性越好,越不容易缺页,跳转或分支越多越容易缺页)

页式系统的不足,页面划分无逻辑含义,页的共享不灵活,页内碎片.

###段式存储管理

进程分段:把进程按逻辑意义划分成多个段,每段有段名,长度不定,进程由多段组成.

段式内存管理系统的内存分配以段为单位,每段分配连续的内存,但是段和段不要求相邻.

段式系统的虚拟地址VA包含段号S和段内偏移W;VA:(S,W)

段时地址的映射机制

段表(SMT)

记录每段在内存中映射的位置,段号S,段的编号(唯一的),段长L(段的长度),基地址B(该段在内存中的首地址)

段式地址的映射过程:首先把逻辑地址VA分离出(S,W);随后查询段表,检索段号S,查询该段基地址B和长度L.物理地址MA=B+W.

段表的扩充:

基本字段:段号,长度,基址

扩展字段:中断位,访问位,修改位,R/W/X

段的共享:共享段在内存中只有一份存储;共享段被多个进程映射到各自段表;需要共享的模块都可以设置为单独的段.

段式系统的缺点:段需要连续的存储空间;段的最大尺寸受到内存大小的限制;在辅存中管理可变尺寸的段比较困难.

*段式系统和页式系统的比较*

| 比较项 | 段式系统 | 页式系统 |
| -----| ---- | ---- |
| 地址空间 | 一维 | 二维 |
| 长度是否可以改变| 是 | 否 |
| 划分意义 | 有 | 无 |
| 共享是否方便 | 是 | 否 |
| 用户可见 | 是 | 否 |
| 偏移是否有溢出 | 是 | 否 |


####段页式存储管理

在段式存储管理中结合页式存储管理技术,在段内划分页

####段式页系统存储管理

段式系统的地址构成:段号S,页号P,页内偏移W

| 段号S | 段内位移W` |

这个W是可以分离的可以编程P和W

内存划分按页分配按页装入.

段页式地址的映射机构,同时采用段表和页表实现地址映射.

系统为每个进程建立一个段表

系统为每个段建立一个页表

段表给出每段的页表基地址及页表长度(段长)

页表给出每页对应的页框

##Intel CPU和Linux内存管理

###Intel CPU的物理结构

*x86的实模式 Real Mode*

Real mode

20位:1M内存空间

地址表示方式:段 16位 偏移16位

段地址4位对齐

*Protect Mode*

32位地址空间:4G内存

支持多任务,任务切换,上下文保护

进程隔离:代码和数据的安全

支持分段机制和分页机制

新的寄存器:

EAX-EDX:扩展到32位

CR0-CR4

GDTR

LDTR

IDTR

控制寄存器CR0

CR0的低5位组成机器状态字(MSW)

PE: 0 Real Mode ; 1 Protect Mode
MP: 1 系统有数学协处理器时
EM: 0 仿真协处理器
TS: 任务切换,切换任务时自动设置
PG: 允许分页

控制寄存器CR2

如果发生缺页,引发的缺页线性地址保存在CR2中

控制寄存器CR3

CR3包含页目录基址:高20位

####*x86CPU架构下的三种地址*

*逻辑地址*:汇编语言(段:偏移)

*线性地址*:由逻辑地址转换得到

*物理地址*:分页;未分页

第一级,段机制(逻辑地址到线性地址);

第二级,分页机制(线性地址到物理地址).

####Intel CPU的段机制

*段与段描述符*

段:一段连续的内存

段描述符:

描述段的属性,8byte

  段基址

  段界限

  段属性

  段类型

  访问该段所需最小特权级

  是否在内存

描述符:

段基址:32位(段基址1+段基址2)

段界限:20位(段界限1+段界限2)

描述符表:用于存放描述符的数组;长度是8字节的整数倍.

类型:全局描述符表GDT(包含所有进程可用的段的描述符,系统只有1个);局部描述符表LDT(包含与特定进程有关的描述符,每个进程都有自己的LDT);中断描述符表IDT(包含中断服务程序段的描述符,类似中断向量表)

选择子(Selector):用于选择GDT/LDT中的某个描述符,存放在段寄存器中,高13位是整数索引.

构成:索引域(INDEX):13位,给出段描述符在GDT或LDT中的位置;TI域,1位,GDT(0)或LDT(1);特权级别域(Request Privilege Level),2位

索引域:给出段描述符在GDT或LDT中的位置

TI域:TI=1 ,从LDT中选择相应的描述符,TI=0,从GDT中选择描述符

特权级别域:请求者最低特权级的限制,只有请求者特权级高于或等于DPL,对应段才能存取,实现段的保护.

例子:LDT基址0012 0000H GDT基址0010 0000H CS=1007H

  问:1请求的特权级是多少?

    2目标段的描述符位于GDT中还是LDT中

    3目标段的描述符的基地址是多少

  解:  CS=1007H = 0001 0000 0000 0111B

      RPL = 3 申请的特权级为3

      TI = 1 描述符位于LDT内

      描述符相对于LDT基址的偏移量为

      0001 0000 0000 0Bx8 = 512x8 = 4096 = 1000H

      段描述符地址为

      0012 0000H + 1000H= 0012 1000H


####Linux页面机制

*硬件分页* Intel CPU的页 :4KB 通过设置CR0的PG位开启分页功能 分页:线性地址->物理地址 在MMU中进行分页.

二级页表地址映射的特点:访问数据需要三次访问内存;页目录调入内存;页表按需要调入主存;页面、页表、页目录的大小都刚好4K(占1个页框)

####Linux对段的支持

Linux将4G虚拟空间划分位两个部分,分别是3G的用户空间,从你0到0xBFFF FFFF,和内核空间1G,从0xC000 0000到0xFFFF FFFF

Linux段机制,段机制对寄存器的初始化:start_thread()

Linux四个范围一样的段:0~0xFFFF FFFF(4G) 分别是 内核数据段、内核代码段、用户数据段、用户代码段.

各段的属性不同,内核特权级为0,用户特权级为3

作用:利用段机制隔离用户数据和系统数据,保留段的登记保护机制;简化(避免)逻辑地址到线性地址的转换,可以直接将虚拟地址当作线性地址,二者完全一致.

=======================================================

#C8 设备管理

1.按交互对象看分类

2.按交互方向分类

3.按外设特性分类

###设备管理的主要功能:设备分配;设备映射;设备驱动

管理设备的主要功能>设备分配

设备分配是设备管理的基本任务;设备分配程序按照一定的策略,为申请设备的进程分配设备,记录设备的使用情况

设备管理的主要功能L>设备映射

物理设备:I/O系统中实际安装的设备 物理名:ID或字符串

逻辑设备:应用软件使用的设备;逻辑名:友好名

设备映射功能:设备管理模块将逻辑设备映射到物理设备的功能;从应用软件的角度看,逻辑设备是一类物理设备的抽象;从设备管理程序来看,物理设备是逻辑设备的实例.

设备哦独立性:物理设备对用户透明,用户使用统一规范的方式使用设备;用户编程时使用设备逻辑名,由系统实现罗就设备到物理设备的转化.

设备管理的主要功能>设备驱动

设备驱动:对物理设备进行控制,实现I/O操作:IN/OUT;接收应用的服务请求(诸如读写命令),转换为具体的I/O操作,控制设备完成呢相关操作;向用户提供统一接口:read/write/open./..也把外设看作文件处理.

设备驱动程序的特点:驱动设备程序与硬件密切相关;每类设备都要配置特定的驱动程序;驱动程序一般由厂商根据操作系统要求编写;操作系统仅对设备驱动的接口提出要求.

###Spooling系统

设备分配的方法

1.独占设备的分配

2.共享设备的分配

3.虚拟分配

独占性设备包括所有的字符型设备;在你任意时间内最多只能被一个进程占用.在使用时,进程首先像系统申请,可能进入阻塞状态,当设备可用时,唤醒一个等待进程;使用完毕后,进程必须释放设备.

共享型设备包括所有块型设备;它的I/O传输单位是块,宏观上,一个共享型设备可以被多个进程同时占用;微观上,多个进程交替使用同一设备;进程使用这类设备时,无需申请或释放资源,也不存在某个进程占用设备的问题.

进程使用独占设备的过程:申请——使用——释放

1.进程申请设备

2.系统分配设备

3.进程发送您使用命令

4.系统将转到设备驱动模块完成一次I/O传输

5.进程释放设备

6.系统呢会i手偶设备.

进程申请成功,直到释放用完之前,独占设备.

共享型设备的分配

进程使用共享型设备不需要申请,当然也就不存在占用或释放设备的问题;但是I/O期间只能嫩难过有一个进程使用设备,因此,进程使用共享型设备之前,有一个隐含的命令,使用完毕之后名,有一个隐含的释放命令,以实现一次基本I/O传输期间的排他性,保证操作的正常进行;使用共享型设备的过程中,进程有可能能进入阻塞等待转身柜台.

###虚拟分配

虚拟技术,在一类物理设备上模拟另一物理设备的技术,借助辅存区域模拟独占设备,将设备转化为共享设备.

虚拟设备,用来模拟独占设备的部分辅存称为虚拟设备,虚拟独占设备

输入井:模拟输入设备的辅存区域

输出井:模拟输出设备的辅存区域


虚拟分配:当进程需要与独占设备交换信息时,就能采用虚拟技术将与该独占设备所对应的虚拟设备(部分辅存)分配给他.

SPOOLing系统是虚拟技术和虚拟分配的实现,Simultaneaus Periphernal Operation Online.外部设备同时联机操作[假脱机输入/输出操作]

SPOOLingde的结构

输入井和输出井

在磁盘上开辟两个存储区域;输入井模拟脱机输入时的硬盘;输出井模拟脱机输出时的磁盘

输入缓存区和输出缓存区

在内存中开辟的存锤区域;输入缓存区暂时存储输入设备,以后再传送到输出井;输出缓存区暂存输出数据,以后再传送到输入井.

输入监控进程和输出监控进程

输入监控进程模拟脱机输入的卫星机,将用户要求的数据从输入设备通过输入缓存区再传输到输入井.当用户进程需要数据时,直接从输入井读入所需设备;

输出监控进程模拟脱机谁出的卫星机,用户进程将输出数据从内存先传输到输出井,当输出设备空闲时,再将输出井的数据传输到输出设备上.


SPOOLing系统原理小节:

任务执行前:预先将程序和数据输入到输入井中

任务运行时:使用数据从输入井中取出

任务运行时:输出数据时,把数据写入输出井

任务运行完:外设空闲时输出全部数据和信息

SPOOLing系统原理小节

提高了I/O速度

将独占设备改造为共享设备,实现了虚拟设备的功能


##设备驱动

###Linux 模块机制

Linux内核模块 Loadable Kernel Module: LKM

解决单体内核机制的不足

  一种未经链接的可执行代码

  经过装载(链接)成为内核的一部分

  可以动态加载或卸载

-----

以下是例子:

```C

#include <linux/module.h>
static int hello_init(){
printk("Hello,Kernel!\n");
return 0;
}
static voiid hello_exit(){
printk("Exit Kernel!\n");
}
module_init(hello_init)
module_exit(hello_exit)

```

-----

###Linux驱动程序(LDD)

|         |---write ioctl -->|      |       |     |
| 应用程序 |                  |驱动程序|<----->|设备  |
|         |---read ioctl --->|      |       |     |

用户态和核态,之前笔记讲过,驱动程序工作在核态

Linux设备的分类:

1.字符设备:以字节为单位逐个进行I/O操作,诸如串口设备.

2.块设备:通过buffer,cache来进行存取,可以随机访问,例如IDE硬盘设备,支持可安装的文件系统

3.网络系统:通过BSD套接口直接访问(SOCKET)

设备文件:

  硬件设备作为文件看待:设备文件

  用文件接口来完成设备的操作,打开、关闭、读写和I/O控制等.

  字符设备和块设备通过设备文件访问,Linux文件系统中可以找到设备文件.

主设备号和次设备号

主设备号:

标识该设备种类,标识驱动程序

主设备号范围:1-255

Linux内核支持动态分类主设备号

次设备号:

标识同一设备驱动程序的不同硬件设备

次设备号只在驱动程序内部使用,系统内核直接把次设备号传递给驱动程序,由驱动程序去管理.

---

完整的LDD结构

设备的打开

释放

读

写

控制

中断和轮询

驱动程序的注册

注销

---

另一个简单的例子(实现了5个函数)

```C

static init my_open(struct inode \*inode,struct file *filp){
设备打开时的操作
}

static init my_release(struct inode \*inode,struct file *filp){
设备关闭时的操作
}

static init_my_write(struct file *file, const char * buffer, size loff_t * ppos)
{设备写入时的操作}

static int my_init(void){
设备的注册:初始化硬件、注册设备、创建设备节点
}

static void my_exit(void){
设备的注销:删除设备节点、注销设备
}
```
---

ps这一章实际编写会涉及makefile,该搞一搞了.(摸了)

###Windows驱动程序

---

例子

```C
#include<ntddk.h>

NTSTATUS DriverEntry(

IN PDRIVER_OBJECT pDriverObject,

IN PUNICODE_STRING pRegistryPath){

NTSTATUS status = STATUS_SUCCESS;

KdPrint(("hello world!\n"));

return;

}
```
用DriverLoader

---

相关函数总结

Windows:

Windows固定采用DriverEntry作为入口函数

给pDriverObject->DriverUnload赋值退出函数指针.

Linux:

module_init(my_init);

module_exit(my_exit);

ps:驱动程序开发工具

Windows DDK(Driver Development Kit)

DriverWorks + Windows ntddk

WinDriver

ps:写驱动时不能调用Windows用户模式API函数

利用IoCreateDevice创建设备对象

--------

#C9 文件系统

文件的定义:文件时计算机存取信息的一种重要组织形式,文件由若干信息箱项构成,信息项可以时字节,可以是结构化数据.

用户通过读写指针来存取文件的信息项,文件具有文件名,用户通过文件名存取文件.

*文件分类*

分类标准1:文件的用途

系统文件,包括操作系统的可执行程序和数据文件,这种文件不对用户开放,仅供系统使用

库文件,系统为用户提供的各种标准函数库和实用程序等,用户只能使用这些文件,无权对其进行修改.

用户文件,用户创建的文件,如用户可执行程序,源程序,数据文件等.这种文件的使用和修改权均属于用户

分类标准2:文件的操作权限

只读文件

读写文件

不保护文件(为所欲为)

分类标准3:文件性质

普通文件,指一般的用户文件或系统文件

目录文件,记录目录里的文件列表信息

设备文件,把设备当作文件管理和使用

*文件属性*

指定文件的类型、操作特性和存取保护等一组信息.

文件属性存放在文件所在的目录的目录文件中.

MS-DOS系统中,文件属性占目录项的一个字节

  0000 0001 只读
  0000 0010 隐藏

*文件系统*

定义:负责管理文件的机构称为文件系统

功能:负责文件的创立、撤销、读写、修改、复制和存取控制等,并管理存放文件的存储设备.

ps:文件系统的目标是让用户以文件名来存取文件

*文件的结构*

逻辑结构(用户的观点),为用户提供逻辑结构清晰、方便使用的文件.

强调文件呢信息项的构成方式和文件的存取方式.

物理结构(系统的观点),文件在存储设备上的存储结构,强调合理利用存储共建,缩短I/O存取时间.

*文件的逻辑结构*

记录式文件

信息项是记录:结构化数据

流失文件

信息项是字节,文件的长度就是字节的数量

*ps:*现代操作系统中文件都是流式文件,由应用程序解释和处理文件.

文件存取的方法:顺序存取,随机存取

*顺序读取*:按文件信息项排列顺序依次存取

读写指针:文件打开时,读写指针指向第一个信息项,每存取1个信息项,读写指针自动加1而指向下一个信息项.

*随机存取*:直接存取,存取时操作指定存取的位置.

特点:

对流式文件或记录为定长的文件容易确定存取位置,对记录不定长的记录式文件比较定位较为麻烦.

##文件的物理结构

概念:文件的物理结构指文件在存储设备上的存储方式,强调合理利用存储空间并缩短I/O时间

类型:连续文件;索引结构;串联文件

*连续文件:*文件按逻辑块的顺序存放在硬盘的连续的物理存储块中,文件目录记录文件长度(块数)和第一个存储块的块号.

特点:文件建立时给出文件最大长度并登记文件的起始位置.有点事简单,支持顺序存取和随机存取,顺序存取熟读快,所需磁盘寻道次数和寻道时间最少.缺点是文件不易动态增长,不利于文件插入和删除,外部碎片问题.

*索引文件:*

概念:文件存放在不连续的存储块中,建立索引表记录文件逻辑块和物理存储块的对应关系;索引表单独放在存储块中.

特点:

文件 = 索引区 + 数据区

先访问索引,再访问数据

支持随机存取和顺序存取

支持文件动态增长、插入、删除

*串联文件*

概念:文件存放在不连续的存储块中,每个存储块都有一个next指针,指向下一个存储块.

文件目录:指明文件名和第一个存储块的块号

特点:使用顺序存取,随机存取较为困难,提高了磁盘空间的利用率,不存在外部碎片,有利于动态扩充、插入和删除.

缺点:存取慢,不适用随机存取;可靠性问题,next指针出错文件访问失败,next指针占用一定空间

FAT文件系统是串联文件系统的应用.

###FAT File Allocation Table

文件访问过程:

1.访问文件目录:找0块的块号i


2.访问FAT找下一块块号

3.FAT(i)=FFFF文件结束

缺点:读取文件时先读FAT,慢.FAT占用存储空间,存储容量越大,存储块越多,FAT元素越多,元素位宽越长,占用更多的额外存储空间.

*扇区* 磁盘上最小的可寻址存储单元(512byte )

*cluster* = 存储块,设备的最小存取单元,固定数量的扇区

例子:360kb的硬盘,cluster = 2个 扇区(1024byte)

  10MB硬盘:cluster = 8个扇区(4096byte)

  2GB硬盘:cluster = 64个扇区簇(32kb)

FAT元素树木和簇的树木一样多, 假设簇数=2^N

FAT元素宽度至少应为2N才能标识全部的簇

N=8:能标识2^8 = 256个以此类推


**磁盘容量 = FAT长度 x 簇容量 = FAT长度 x 簇扇区数 x512 byte**

若N = 64,则簇扇区数=64

FAT16文件系统:

以簇为单位管理磁盘,簇是扇区的背书,是2的N次幂,最大64扇区.

FAT16表元素宽度2byte,即16Bit

每簇最大64扇区:磁盘分区最大2G

FAT16格式化的磁盘呢如下所示:

| 启动扇区 | FAT1 | FAT2 | 根目录 | 其他目录和文件 |

###存储空间管理

功能,记录磁盘使用情况,管理和分配、回收存储空间

记录磁盘空闲块的方法:空闲目录文件、空闲块链、位示图

空闲目录文件

空闲文件:把连续空闲看成一个特殊文件每,由多个连续空闲块组成

空闲文件目录

所有空闲文件代表存储设备的全部空闲空间;

为空闲文件建立专门的目录,空闲文件目录

每一个表项对应一个空闲文件每,包括第一个空闲块号,空闲块个数等信息.

空闲块链:把所有的空闲块链接在一起,当申请者需要空闲块时,链头开始搜索所需的空闲块,当回收空闲块时,把释放的空闲块逐个加在链尾.

位示图:从内存中划出若干个字节,每个bit表示1个存储块空闲或占用状态.

文件目录:文件名址录,记录文件名和存放地址的目录表,具有将文件名呢转换为物理地址的功能

文件属性也记录在目录中

目录文件:文件以目录的形式存于外存,这个文件叫目录文件

目录结构:不同的系统,文件目录的组织也不完全相同

DOS系统(32字节)

UNIX:索引节点,文件目录项目]中的文件名和其他属性信息分开,后者单独组成一个定长的数据结构,索引节点i_node.

目录可以做多级.

文件的路径分为绝对路径和相对路径

文件的保护,没通过chmod给文件赋予各种权限

典型的文件系统:FAT16 FAT32 NTFS EXT2 EXT3 EXT4 ···
