#操作系统课程学习笔记

##C1 操作系统呢概述

常用四大操作系统:Win Mac Linux Unix

###操作系统的基本功能

  提供操作界面

  控制程序运行

  管理系统资源

  配置系统参数

  监控系统状态

  工具软件集合

###操作系统的功能

  进程管理（CPU管理）[控制、调度、通信]

  内存管理[内存分配 内存共享 内存保护 虚拟内存]

  设备管理[设备的分配和调度 设备传输控制 设备驱动]

  文件管理[存储空间管理 文件的操作 目录的操作 文件和目录的存取权限管理]

Def操作系统是一个大型系统程序，它负责给用户提供接口，方便用户控制计算机；负责为应用程序分配和调度软硬件资源，并且控制程序的并发活动，帮助用户存取和保护信息。

系统程序在层次上处于应用程序和硬件之间的部分。


###操作系统的发展历程

  电子管时代

  晶体管时代

  集成电路时代

  大规模集成电路时代

###操作系统发展的四个典型阶段

  手工操作（无操作系统阶段）

  单道批处理系统

  多道批处理系统

  分时系统

###分时技术

由于多道批处理系统存在作业处理时间长、交互能力差等等缺点，在60年代基于中断技术和通道技术的出现而发展出了分时操作系统
它的交互性更高、响应更加快速，也支持多用户多任务。主机采用分时技术轮流为每个使用串口线接入主机的终端提供服务，对于每个终端来说都认为自己是独占主机的。

###分时技术的概念

  主机以很短的时间片（50ms）为单位，把cpu轮流分配给每个终端使用，直到全部作业被运行完。由于时间片非常短，在终端数量不多的情况下，每个终端都能重新获得CPU，使得每个终端都能获得及时响应。

  等待周期==时间片x终端数量

  大型分时系统的一种时间Multics项目。

  Unix是第一个实用化的分时系统，它的创新之处在于其可移植性和硬件无关性。它引入了“特殊文件”这一概念，将外设看作一种文件对外设进行统一管理。


###操作系统的典型案例

*微机操作系统* CP/M MacOS DOS Windows

*实时操作系统* 火控 雷达 跟踪识别等等系统

*网络操作系统* 普通操作系统+网络通信+网络服务



=======================================================

#C2操作系统逻辑结构

##分层的操作系统

    资源分配与调度
        ｜｜
        ｜｜
      文件存取
        ｜｜
        ｜｜
      I/O处理
        ｜｜
        ｜｜
      存储管理
        ｜｜
        ｜｜
      进程管理
  初级中断管理/裸机/处理机分派

##分层的原则

硬件相关————最底层

外部特征————最外层

中间层————调用次序或消息传递顺序

共性的服务————较低层

活跃功能————较低层

分层的有点是:1结构清晰，避免循环调用；2.容易将问题局部化，系统的正确性容易保证；3.有利于系统的维护、扩充、移植。

##微内核结构

操作系统 == 微内核 + 核外服务器

微内核（足够小，提供OS最基本的核心功能和服务）

核外服务器 （能完成OS大部分的服务功能，等待App提出请求）

相关项目可以参考Linux和Minix


##操作系统的逻辑结构

CPU的态 即CPU的工作状态，对资源和权限使用指令的描述。

态可分为:核态（Kernel mode 可访问所有资源和执行所有指令）；用户态（User mode 仅可以访问部分资源，其他资源受限）；管态(Supervisor mode 介于核态和用户态之间)

用户态在以下四种情况发生时可向核态转换:

1.请求OS服务

2.中断发生

3.Error

4.企图执行特权指令

核态向用户态转移的情况一般是执行中断返回:IRET

硬件按“态”来区分CPU的咋混改

OS按“进程”来区分CPU的状态

##存储器

###存储器的分类:

1.按读写方式可分为RAM和ROM

2.按存储材料可分为半导体存储器、磁存储器、光存储器

3.按和CPU的联系可分为主存和辅存

一个理想的储存体系应该应对不同的存储需求有不同的成本和架构，它的大致要求是速度快、容量大、成本低


##CPU读取指令互数据时的访问顺序:

1.访问缓存

2.访问内存

3.访问辅存

##中断

###定义
中断即CPU对突发的外部事件的反应过程或者机制（CPU收到外部信号之后停止当前工作去处理外部事件，随后回到原来的中断点继续工作）

引入中断的目的在于实现并发、实现实时处理、实现故障的自动处理

引起中断的事件被称为中断源，中断分为强迫性中断和自愿中断。也可分为外中断和内中断，外中断由CPU外部事件引发，内中断相反；外中断又分为可屏蔽和不可屏蔽，依据是CPU是否可以不响应。

断点:即程序中断的地方 CS:IP

现场:程序正确运行所依赖的信息集合。

##中断响应的过程:

1.识别中断源

2.保护断点和现场

3.装入中断服务程序的入口地址（CS:IP）

4.装入中断服务程序

5.恢复现场和断点

6.中断返回:IRET

##中断响应的实质是交换指令执行地址和交换CPU的态


=======================================================

#C3 操作系统用户界面

##BIOS和主引导记录MBR

###实模式和保护模式

####实模式（REAL MODE）

程序按照8086寻址方法访问0h-FFFFFh（1MB）空间

寻址方式:物理寻址（20bit） = 段地址:偏移地址

例子:读取1M空间

前640K [00000-9FFFF]:基本内存

中128K [A0000-BFFFF]:显卡显存

末尾256K [C0000-FFFFF]:BIOS

C0000 -- C7FFF:显卡BIOS

C8000 - CBFFF:IDE控制器BIOS

F0000-FFFFF:最后64K 系统BIOS

CPU单任务运行

####保护模式（内存保护模式 PROTECT MODE）

寻址方式:段（32bit）和偏移量（32bit）寻址4GB空间

段页式寻址机制（段 页）

寻你地址，进程，封闭空间

应用承诺许和操作系统的运行环境都被保护

CPU支持多任务

###系统BIOS

####Basic I/O System(Frimware固件)

基本输入/输出系统

位置:F0000 - FFFFF

功能:

  系统启动配置

  基本的设备I/O服务

  系统的加电自检和启动

####CMOS设置 启动时按DEL就会进入CMOS设置，即使什么OS都没装也会进到这里

###MBR/硬盘分区/格式化


MBR ===> Windows FAT32/NTFS ===>Linux EXT2/EXT3/... ===>其他文件系统

分区启动扇叶 PBR

主启动扇叶:完成OS加载或者启动你难过管理功能

  提供菜单:让用户选择不同的启动项 实现多重启动

  加载核心文件:直接指向可启动区加载操作系统

  跳转:将启动管理功能转交给其他Loader

运行过程: POST->CMOS设置（硬盘启动）->读取MBR->控制权交给MBR

MBR读取分区表，找到其中的活动分区，确认其他分区都是不活动的，MBR读取互动分区中的第一个分区并将其加载到内存中。

PBR继续控制后续引导过程

###操作系统启动过程：初始引导==>核心初始化==>系统初始化

####初始引导 它的目的在于把OS核心装入内存并使之开始工作接管计算机系统

过程：加电 JUMP POST ==>BIOS中的启动程序运行 ==>引导程序运行==>OS内核逐步加载剩余OS部分，最后完全控制计算机

####核心初始化 它的目的在于初始化系统核心数据

它的典型工作又 各种寄存器的初始化；存储系统和页表的初始化；核心进程的构建

####系统初始化 它的目的在于为用户使用系统作准备 使系统处于待命状态

它的主要工作有 初始化文件管理系统 初始化网络系统 初始化控制台 初始化图形界面

例子 Windows的启动过程

POST 加电后BIOS启动主机自检程序

初始引导 BIOS从MBR读入引导程序，装入内存的特定位置； 引导程序启动DOS7.0调入操作系统核心；Windows开始接管系统

核心初始化 资源状态、核心数据等初始化

系统初始化 GUI界面生成，系统处于待命/消息接收状态

例子 LINUX系统启动状态

POST->MBR->KERNEL映像->KERNEL映像自解压并执行->内核初始化->内核启动


##操作系统的生成

操作系统的生成嫩难过是为了满足特定硬件环境和用户需要，组装和构建操作系统的过程。

操作系统生成的主要步骤，根据硬件环境/用户要求配置功能模块和狗仔参数

构建OS的映像

系统生成的前提有三：1.操作系统由可拆装模块构成；2有交互式配置工具；3.有映像构建工具

//本节课的实验是配置LINUX内核//

##操作系统的用户界面
Shell是操作系统与用户的交互界面 通过控制台执行命令的方式来进行交互，SHell本身不执行命令，仅仅是管理和组织

Shell脚本由Shell环境解释运行，需要用Chmod赋予可执行属性 x

一般执行使用bash

##系统调用

定义 操作系统内核为应用程序提供的服务/函数

特点 一般涉及核心资源或者硬件编号 每个系统调用具有唯一编号 调用过程产生中断 自愿中断

大体过程是应用程序执行过程中调用函数 产生中断，函数调用系统内核的X功能 随后恢复调用现场 应用继续执行

=======================================================
#C4 进程 【重点】

###基本概念

进程是程序在某个数据集合上的一次运行活动

数据集合：软/硬件环境，多个进程共存/共享环境

进程的特征：

动态性：进程是一个一次性执行的过程，动态的产生和消亡

并发性：进程同其他进程一起向前推进

异步性：进程按照各自的速度向前推进

独立性：进程是系统分配资源和调度CPU的单位

它和程序的区别在于下列三点：1.进程是动态的，程序是静态的;2.暂停和长存，程序是长存的，进程是驻留的；3.一个程序可能对应多个进程

进程可以依据使用资源的权限分为系统进程和用户进程，可根据对CPU的依赖性分为偏CPU进程和偏I/O进程；其他标准亦可分

###进程的状态

分为三种：1.运行状态；2.就绪状态;3.阻塞状态

###进程的描述

重要概念*进程控制块PCB* 这个概念是进程的标志，创建进程时创建PCB；撤销进程后撤销PCB

进程 == 程序 + PCB

###进程的控制

这个概念用于描述在进程生存期间对其全部行为的控制，其中有4个典型的控制行为分别为：创建、阻塞、撤销、唤醒

####创建

创建一个空白的PCB 赋予进程标识符ID 分配空间 初始化 随后插入进程队列

####撤销

在PCB队列中检索出该PCB  获取去运行状态 若处在运行态，立即终止  释放占有资源  讲进程从你PCB队列中移除

####阻塞

停止运行   将PCB由运行态改为阻塞态 插入相应原因的阻塞队列 专调度程序

####唤醒

####进程控制原语 由若干指令构成的具有特定工程的函数 具有原子性

以上四种操作对应四种原语

####Windows 通过 CreateProcess()函数创建进程

####Linux通过fork()函数创建进程

ps:由于父进程和子进程是并发关系，不加控制的情况下不能确定先后

##线程

定义：线程是一个可由CPU直接运行的实体；一个进程可以创造多个线程；多个线程共享CPU可以实现并发运行。

例子 Java语言中的CreateThread()等系列函数 GPSGateway中写过这个

单线程程序：只有一个线程，Windows程序缺省只有1个线程

多线程程序：整个进程至少有2个线程，主线程和至少一个用户线程

线程技术典型应用与需要多个功能并发运行的场景和为了提高窗口的交互性，给后台执行单独写一个线程以避免后台在运行的时候导致交互界面卡死。

使用线程的麻烦之处在于：程序难以调试；线程安全问题；并发过程不好控制。

##临界区和锁

临界资源：一次只允许一个进程独占访问（使用）的资源

临界区和临界资源的特性有：具有排他性；并发进程不能进入临界区

临界区设计四原则：忙则等待；空闲让进；有限等待；让权等待

锁的本质是一个标志，标志线程的可用和不可用状态，实际应该是一个Boolean型变量或者其他实例，通过指定方法去修改这个flag的值。

##同步和P-V操作

进程中可能存在互斥的情况，诸如临界区中的变量。由于多个进程共享了独占性资源，必须对资源的存取顺序进行协调。同步即若干进程为了完成一个共同呢的任务需要互相协调运行步伐。这一部分设计到之前学习的AOE网的知识。

####信号灯的概念，这是一种用于控制同步的基本思想，进程在运行过程中首信号灯的控制没，并可以改变信号灯的状态。

  在这个过程中 信号灯的状态是可以阻塞或唤醒的

信号灯的数据结构，需要定义一个二元矢量（S,q）S为信号量，初始非负，q为PCB队列，初始为空

这个数据结构只对应两个操作 P操作和V操作 分别代指通过和释放

####P操作的原理：S值-1 如果大于等于0则进程继续，若小于0 则进程阻塞并加入队列q中并转调度函数

####V操作的原理：S值+1 若和大于0，则进程继续，若小于0 则该进程同时从q中唤醒一个进程

P-V操作被设计出来用于解决同步和互斥的问题，具体过程是在进入临界区之前先执行P草哦做，离开临界区之后执行V操作。

可以用P-V操作实现同步机制，让运行条件不满足时进程暂停；运行条件满足时，进程继续。

P-V操作应用于同步操作的基本思路：

  暂停当前进程，在关键操作之前执行P操作，继续进程，在关键操作执行之后执行V操作。

###进程通信

使用管道机制来实现，管道的定义是一个进程A可以通过管道将数据传输给另一个进程B，前者向管道输入数据，后者向管道读取数据。（有点像Kafka的Consumer和Produceer模型）

ps：管道通信是单向的，如果要实现双向通信则需要建立两个管道。

在Linux系统中存在*信号*这一通信机制，所谓信号即向进程发送一个通知，通知某一事件已发生。 收到信号的进程可以立即执行操作。

例子 Ctrl+C 即杀死一个进程 收到Signal 执行结束进程操作 Ctrl+Z是挂起 kill-9顾名思义

信号的产生可以是特殊键盘组合、执行终端命令、调用对应函数、硬件异常或者核异常。

=======================================================

#C5死锁

##哲学家吃饭问题，五个哲学家对应5支筷子，对应P-V操作解决这个问题。

在两个或多个进程中，两个或多个进程多持有某种资源，但又继续申请其他某种已经持有的资源，每个进程都拥有其运行所需的一部分资源，但又都不够，从而每个进程都不能向前推进，陷于阻塞状态，这种状态称之为死锁。

##死锁的起因，根本原因是系统资源有限，或者并发推进的顺序不当。

参与死锁的进程大概是两个

参与死锁的进程至少有2个已经占有资源

参与死锁的进程都在等待资源

参与死锁的进程是当前系统中所有进程的子集

死锁回大量占用系统资源

##死锁的起因

###死锁的必要条件

1.互斥条件

2.不剥夺条件

3.环路条件

4.部分分配条件

####预防死锁

破坏上述4个条件

####避免死锁

银行家算法

只需要较弱的限制条件 算法实现难度大

####检测和恢复死锁

允许死锁发生，通过检测机制及时检测出死锁并将进程从这个过程中解脱出来

预先静态分析发 可能被延迟执行 应用开销可能比较大 资源利用率低

有序资源分配法 给系统中的每一个资源分配一个唯一的序号 每次进程在申请资源的时候只能申请序号最大的资源 每次申请只能申请序号大于M的资源 而不能再申请小于或者等于M的资源

这种方法*序号是递增的*

=======================================================

#C6进程调度

在合适的时候以一定策略来选择一个就绪进程进行运行。

进程调度的目标

1.响应速度尽量快

2.处理时间尽可能短

3.系统吞吐量尽可能大

4.资源利用率尽可能高

5.对进程要公平

6.避免饥饿

7.避免死锁

##典型的调度算法

1.先来先服务调度 First Come First Service

按照作业进入系统的先后时间来挑选做噢耶，先进入系统的作业优先被运行。

特点：容易实现，效率不高

只考虑作业等候时间，不考虑运行时间的长短。

2.短作业优先调度算法 Short Job First

选取时间最短者优先调度资源

特点：容易造成饥饿现象

3.响应比高者优先调度算法

响应比 = 响应时间/运行时间 = (响应时间+运行时间)/响应时间

算法：选择响应比最高的作业优先投入运行。

4.优先数调度

算法：根据进程优先数，把CPU分配给优先数最高的进程。

优先数 = 静态优先数 + 动态优先数

静态优先数：在进程创建时产生的，保持不变 它会考虑进程运行所需的资源和长短、类型等等。

动态优先数：随着进程运行而改变

5.循环轮转屌哦度 Round Robin

利用队列，把所有的就绪进程按照先入先出的办法，以时间片q为单位使用CPU，在逻辑上所有的进程构成一个环。

优点：公平、交互

q不能太大

循环轮转调度算法，是第5中的改进，q的大小可以调整。

##Linux中的进程调度策略

task_struct是调度时候的依据

子进程新建时的counter会从父进程的时间片中继承一半，防止恶意用户无限制创建进程调度cpu资源

中断处理过程直接调用schedule（） 该函数用户态无法调度

=======================================================

#C7内存管理

###静态地址映射

程序装入时由操作系统完成逻辑地址到物理地址的映射

逻辑地址：VA

装入地址：BA

物理地址：MA = BA+VA

###存储器功能需求

容量足够大

速度足够快

信息可以永久保存

多道程序并行

#实际的存储器体系

Cache + 内存 + 辅存

基本原理：当内存不够用的时，用辅存在支援内存；暂时不运行的模块换出到辅存上，必要时换入内存。

###固定地址映射

定义：编程和编译时确定逻辑地址和物理地址的映射关系。

特点：程序的加载必须放在指定的内存区域，但是容易产生地址冲突，运行失败。

特点：程序运行之前可以确定映射关系，程序装入之后不能移动，必须放回到原来的位置，程序占用连续的内存空间。


###静态地址映射

定义：程序装入时由操作系统完成逻辑地址到物理地址的映射。

特点：需要在程序运行之前确定映射关系；程序装入后不能移动，如果要移动必须放回原来的位置；程序会占用连续的内存空间。

=====
